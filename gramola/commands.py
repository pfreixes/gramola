# -*- coding: utf-8 -*-
"""
Commands are called fromm the entry points generated by the setuptools or 
by external progams that are using Grmola as a library. The set of commands supported are:

  * gramola datasource             : Show a specific datasource.
  * gramola datasource-test        : Test a specific datasource.
  * gramola datasource-list        : List all datasources.
  * gramola datasource-rm          : Remove one datasource.
  * gramola datasource-add         : Add a new datasource.
  * gramola datasource-echo        : Echo a datasource.
  * gramola query                  : Run a metrics query.
  * gramola dashboard              : Show a specific dashboard.
  * gramola dashboard-list         : List all dashboards.
  * gramola dashboard-rm           : Remove a dashboard.
  * gramola dashboard-rm-query     : Remove a specific query from one dashboard.
  * gramola dashboard-query        : Run all dashboard metrics.

:moduleauthor: Pau Freixes, pfreixes@gmail.com
"""
import sys
import skparkline

from gramola import log
from gramola.datasources.base import DataSource

class GramolaCommand(object):
    @staticmethod
    def execute(*args, **kwargs):
        raise NotImplemented()

    @classmethod
    def find(cls, command_name):
        """Returns the Command implementation for a specific command name."""
        try:
            return next(c for c in cls.__subclasses__() if c.NAME == command_name)
        except StopIteration:
            raise KeyError(command_name)

    @classmethod
    def help(cls):
        return "\n".join([
            "Global Options:",
            "    -v Run in verbose mode",
            "    -q run quite",
            "    --store <directory> Use an alternative path as store, deafaults to .gramola",
            "",
            "Subcommands availables:"] +\
            ["{name}: {description}".format(cls.NAME, cls.DESCRIPTION) for c in cls.__subclasses__()])


class DataSourceCommand(GramolaCommand):
    NAME = 'datasource'
    DESCRIPTION = 'Get a datasource'

    @staticmethod
    def execute(name, store=None):
        """ Returns info about one specific datasource as a dictionary with all
        key values saved. For Example:

            {
                "type": "graphite",
                "name": "datasource name",
                "url": "http://localhost:9000"
           }
    
        :param name: Name of the datasource.
        :param store: Alternatvie :class:`gramola.store.Store` to the default one.
        :rtype: dict.
        :raises KeyError: If the given datasource name does not exist.
        """
        user_store = store or DefaultStore()

        try:
            return filter(lambda datasource: datasource['name'] == name, user_store.datasources())[0]
        except IndexError:
            raise KeyError(name)


def datasource_test(name, store=None):
    """ Test an already saved datasource.
    
    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :raises gramola.datasource.DataSourceNotFound: If the given name does not exist.
    """
    raise NotImplemented()


def datasource_rm(name, store=None):
    """ Removes an already saved datasource.
    
    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :rtype: boolean.
    :raises gramola.datasource.DataSourceNotFound: If the given name does not exist.
    """
    raise NotImplemented()


def datasource_add(name, store=None, dry_mode=False, test=True, **datasource_params):
    """ Add a new datasource with a specific `name`. The params of the datasource depends
    of the type of data source.
    
    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :param dry_mode: Dont save at last, usefull combined with `test` enabled to check
                     that the datasource works.
    :param datasource_params: Specific keyword arguments for the datasource.
    :rtype: boolean.
    :raises KeyError: If the type of data source is not implemented.
    :raises gramola.datasource.InvalidDataSourceConfig: The datasource_params are invalid.
    :raises gramola.store.DuplicateEntry: If the datasource name already exists.
    """
    # find the right class ipmlementation
    cls_datasource = DataSources.find([datasource_params['type']])

    # create a spceific configuration for this data source and instantiate
    config = cls_datasource.DATA_SOURCE_CONFIGURATION_CLS(**datasource_params)
    data_source = cls_datasource(config)

    # if test is not disabled specifically the datasource wont be saved
    # until it will pass the test step.
    if test:
        try:
            if not data_source.test():
                log.error("Testing the datasource .... Failed")
                return False
            log.info("Testing the datasource .... Ok")
        except Exception, e:
            log.error("Testing the datasource .... Error")
            raise e

    if dry_mode:
        log.info("Running in dry-mode, nothing more todo")
        return True

    user_store = store or DefaultStore()
    user_store.save_datasource(config)


class DataSourceEchoCommand(GramolaCommand):
    NAME = 'datasource-echo'
    DESCRIPTION = 'Echo a datasource configuration'

    @staticmethod
    def execute(**datasource_params):
        """ Echo a datasource configuration to be used by query command
    
        :param name: Name of the datasource.
        :param store: Alternatvie store to the default Gramola directory store.
        :rtype: boolean.
        :raises KeyError: If the type_ of data source is not implemented.
        :raises gramola.datasource.InvalidDataSourceConfig: The datasource_params are invalid.
        """
        # A echo command doesnt need the name keyword even it is required, because
        # we share the same interface than the command to add datasources we have to 
        # give a automatic name to avoid raise a InvalidDataSourceConfig error
        temporaly_params = {'name':'stdout'}
        temporaly_params.update(datasource_params)
        return DataSource.find(
            datasource_params['type']).DATA_SOURCE_CONFIGURATION_CLS(
                **temporaly_params).dumps()
 

def datasource_list(store=None):
    """ List all datasouces.
    
    :param store: Alternatvie store to the default Gramola directory store.
    :rtype: list.
    :raises: KeyError, gramola.datasources.InvalidDataSourceConfig, gramola.store.DuplicateEntry
    """
    user_store = store or DefaultStore()
    return user_store.datasources()


class QueryCommand(GramolaCommand):
    NAME = 'query'
    DESCRIPTION = 'Query for a specific metric.'

    @staticmethod
    def execute(name, store=None, **query_params):
        """ Runs a query using a datasource and print it as a char graphic
    
        :param name: Name of the datasource used, the datasource will be get from
                     the user store. Algoutght special char `-` can be used to give
                     the full datasource config from the stdin.
        :param store: Alternatvie :cls:`gramola.store.Store` to the default Gramola directory store.
        :raises KeyError: If the given datasource name does not exist.
        """
        try:
            config = filter(lambda datasource: datasource['name'] == name, user_store.datasources())[0]
        except IndexError:
            raise KeyError(name)

        cls = DataSource.find(config['type'])
        query = cls.METRIC_QUERY_CLS(**query_params)
        datapoints = cls.from_config(**config).datapoints(query)
        return sparkline.sparkify([value for value, ts in datapoints])


def gramola():
    """ Entry point called from binaries generated by setuptools. Beyond
    the main command Gramola immplements a sub set of commands that each one
    implements an specific opeartion. The anatomy of a Gramola command looks like:

        $ gramola <global options> <subcomand> <subcomand options> <args ..>
    """
    log.setup(verbose=v, silent=q)
