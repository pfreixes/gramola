# -*- coding: utf-8 -*-
"""
Commands are called fromm the entry point generated by the setuptools. The set
of commands supported are:

  * gramola datasource             : Show a specific datasource.
  * gramola datasource-test        : Test a specific datasource.
  * gramola datasource-list        : List all datasources.
  * gramola datasource-rm          : Remove one datasource.
  * gramola datasource-add         : Add a new datasource.
  * gramola datasource-echo        : Echo a datasource.
  * gramola query                  : Run a metrics query.
  * gramola dashboard              : Show a specific dashboard.
  * gramola dashboard-list         : List all dashboards.
  * gramola dashboard-rm           : Remove a dashboard.
  * gramola dashboard-rm-query     : Remove a specific query from one dashboard.
  * gramola dashboard-query        : Run all dashboard metrics.

:moduleauthor: Pau Freixes, pfreixes@gmail.com
"""
import sys
import sparkline

from json import loads

from gramola import log
from gramola.datasources.base import (
    DataSource,
    InvalidMetricQuery,
    InvalidDataSourceConfig
)


class GramolaCommand(object):
    @staticmethod
    def execute(*args, **kwargs):
        raise NotImplemented()

    @classmethod
    def find(cls, command_name):
        """Returns the Command implementation for a specific command name."""
        try:
            return next(c for c in cls.__subclasses__() if c.NAME == command_name)
        except StopIteration:
            raise KeyError(command_name)

    @classmethod
    def help(cls):
        return "\n".join([
            "Global Options:",
            "    -v Run in verbose mode",
            "    -q run quite",
            "    --store <directory> Use an alternative path as store, deafaults to .gramola",
            "",
            "Subcommands availables:"] +
            ["{}: {}".format(cls.NAME, cls.DESCRIPTION) for c in cls.__subclasses__()])


class DataSourceCommand(GramolaCommand):
    NAME = 'datasource'
    DESCRIPTION = 'View the details of a saved datasource'

    @staticmethod
    def execute(name, store=None):
        """ Returns info about one specific datasource as a dictionary with all
        key values saved. For Example:

            {
                "type": "graphite",
                "name": "datasource name",
                "url": "http://localhost:9000"
            }

        :param name: Name of the datasource.
        :param store: Alternatvie :class:`gramola.store.Store` to the default one.
        :rtype: dict.
        :raises KeyError: If the given datasource name does not exist.
        """
        user_store = store or DefaultStore()

        try:
            return filter(lambda d: d['name'] == name, user_store.datasources())[0]
        except IndexError:
            raise KeyError(name)


def datasource_test(name, store=None):
    """ Test an already saved datasource.

    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :raises gramola.datasource.DataSourceNotFound: If the given name does not exist.
    """
    raise NotImplemented()


def datasource_rm(name, store=None):
    """ Removes an already saved datasource.

    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :rtype: boolean.
    :raises gramola.datasource.DataSourceNotFound: If the given name does not exist.
    """
    raise NotImplemented()


def datasource_add(name, store=None, dry_mode=False, test=True, **datasource_params):
    """ Add a new datasource with a specific `name`. The params of the datasource depends
    of the type of data source.

    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :param dry_mode: Dont save at last, usefull combined with `test` enabled to check
                     that the datasource works.
    :param datasource_params: Specific keyword arguments for the datasource.
    :rtype: boolean.
    :raises KeyError: If the type of data source is not implemented.
    :raises gramola.datasource.InvalidDataSourceConfig: The datasource_params are invalid.
    :raises gramola.store.DuplicateEntry: If the datasource name already exists.
    """
    # find the right class ipmlementation
    cls_datasource = DataSources.find([datasource_params['type']])

    # create a spceific configuration for this data source and instantiate
    config = cls_datasource.DATA_SOURCE_CONFIGURATION_CLS(**datasource_params)
    data_source = cls_datasource(config)

    # if test is not disabled specifically the datasource wont be saved
    # until it will pass the test step.
    if test:
        try:
            if not data_source.test():
                log.error("Testing the datasource .... Failed")
                return False
            log.info("Testing the datasource .... Ok")
        except Exception, e:
            log.error("Testing the datasource .... Error")
            raise e

    if dry_mode:
        log.info("Running in dry-mode, nothing more todo")
        return True

    user_store = store or DefaultStore()
    user_store.save_datasource(config)


class DataSourceEchoCommand(GramolaCommand):
    NAME = 'datasource-echo'
    DESCRIPTION = 'Echo a datasource configuration'

    @staticmethod
    def execute(**datasource_params):
        """ Echo a datasource configuration to be used by query command

        :param name: Name of the datasource.
        :param store: Alternatvie :class:`gramola.store.Store` to the default one.
        :rtype: boolean.
        :raises KeyError: If the type_ of data source is not implemented.
        :raises gramola.datasource.InvalidDataSourceConfig: The datasource_params are invalid.
        """
        # A echo command doesnt need the name keyword even it is required,
        # we share the same interface than the command to add datasources then
        # we have to give a automatic name to avoid raise an
        # InvalidDataSourceConfig error
        temporaly_params = {'name': 'stdout'}
        temporaly_params.update(datasource_params)
        return DataSource.find(
            datasource_params['type']).DATA_SOURCE_CONFIGURATION_CLS(
                **temporaly_params).dumps()


class DataSourceListCommand(GramolaCommand):
    NAME = 'datasource-list'
    DESCRIPTION = 'List all saved datasources'

    @staticmethod
    def execute(store=None):
        """ List all datasouces.

        :param store: Alternatvie :class:`gramola.store.Store` to the default one.
        :return: list of derivated instancess of
                 :class:`gramola.datasources.base.DataSourceConfig`
        """
        user_store = store or DefaultStore()
        return user_store.datasources()


class QueryCommand(GramolaCommand):
    NAME = 'query'
    DESCRIPTION = 'Query for a specific metric.'

    @staticmethod
    def execute(name, store=None, **query_params):
        """ Runs a query using a datasource and print it as a char graphic

        :param name: Name of the datasource used, the datasource will be get from
                     the user store. Altought special char `-` can be used as alternative
                     to read the datasource config from the stdin.
        :param store: Alternatvie :cls:`gramola.store.Store` to the default Gramola directory store.
        :raises InvalidDataSourceConfig: Data source config is invalid.
        :raises InvalidMetricQuery: Query params are invalid.
        :raises KeyError: If the given datasource name does not exist.
        :raises ValueError: If the given datasource from stdin is not well formatted.
        """
        if name == '-':
            buffer_ = sys.stdin.read()
            config = loads(buffer_)
        else:
            try:
                config = filter(lambda d: d['name'] == name, user_store.datasources())[0]
            except IndexError:
                raise KeyError(name)

        cls = DataSource.find(config['type'])
        query = cls.METRIC_QUERY_CLS(**query_params)
        datapoints = cls.from_config(**config).datapoints(query)
        return sparkline.sparkify([value for value, ts in datapoints])


def gramola():
    """ Entry point called from binaries generated by setuptools. Beyond
    the main command Gramola immplements a sub set of commands that each one
    implements an specific opeartion. The anatomy of a Gramola command looks like:

        $ gramola <global options> <subcomand> <subcomand options> <args ..>
    """
    log.setup(verbose=v, silent=q)
