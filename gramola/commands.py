# -*- coding: utf-8 -*-
"""
Commands are called fromm the entry point generated by the setuptools. The set
of commands supported are:

  * gramola types                  : List of the datasource types supported.
  * gramola datasource             : Show a specific datasource.
  * gramola datasource-test        : Test a specific datasource.
  * gramola datasource-list        : List all datasources.
  * gramola datasource-rm          : Remove one datasource.
  * gramola datasource-add-<type>  : Add a new datasource.
  * gramola datasource-echo-<type> : Echo a datasource.
  * gramola query-<type>           : Run a metrics query.
  * gramola dashboard              : Show a specific dashboard.
  * gramola dashboard-list         : List all dashboards.
  * gramola dashboard-rm           : Remove a dashboard.
  * gramola dashboard-rm-query     : Remove a specific query from one dashboard.
  * gramola dashboard-query        : Run all dashboard metrics.

:moduleauthor: Pau Freixes, pfreixes@gmail.com
"""
import sys
import optparse
import sparkline

from json import loads

from gramola import log
from gramola.contrib.subcommand import (
    Subcommand,
    SubcommandsOptionParser
)
from gramola.datasources.base import (
    DataSource,
    InvalidMetricQuery,
    InvalidDataSourceConfig
)


class GramolaCommand(object):
    # to be overriden by commands implementations
    NAME = None
    DESCRIPTION = None
    USAGE = None

    @staticmethod
    def execute(*args, **kwargs):
        raise NotImplemented()

    @staticmethod
    def options():
        return []

    @classmethod
    def find(cls, command_name):
        """Returns the Command implementation for a specific command name."""
        try:
            return next(c for c in cls.__subclasses__() if c.NAME == command_name)
        except StopIteration:
            raise KeyError(command_name)

    @classmethod
    def commands(cls):
        """Returns the commands implementations"""
        return cls.__subclasses__()


class DataSourceCommand(GramolaCommand):
    NAME = 'datasource'
    DESCRIPTION = 'View the details of a saved datasource'
    USAGE = '%prog NAME'

    @staticmethod
    def execute(name, store=None):
        """ Returns info about one specific datasource as a dictionary with all
        key values saved. For Example:

            {
                "type": "graphite",
                "name": "datasource name",
                "url": "http://localhost:9000"
            }

        :param name: Name of the datasource.
        :param store: Alternatvie :class:`gramola.store.Store` to the default one.
        :rtype: dict.
        :raises KeyError: If the given datasource name does not exist.
        """
        user_store = store or DefaultStore()

        try:
            return filter(lambda d: d['name'] == name, user_store.datasources())[0]
        except IndexError:
            raise KeyError(name)


def datasource_test(name, store=None):
    """ Test an already saved datasource.

    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :raises gramola.datasource.DataSourceNotFound: If the given name does not exist.
    """
    raise NotImplemented()


def datasource_rm(name, store=None):
    """ Removes an already saved datasource.

    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :rtype: boolean.
    :raises gramola.datasource.DataSourceNotFound: If the given name does not exist.
    """
    raise NotImplemented()


def datasource_add(name, store=None, dry_mode=False, test=True, **datasource_params):
    """ Add a new datasource with a specific `name`. The params of the datasource depends
    of the type of data source.

    :param name: Name of the datasource.
    :param store: Alternatvie :class:`gramola.store.Store` to the default one.
    :param dry_mode: Dont save at last, usefull combined with `test` enabled to check
                     that the datasource works.
    :param datasource_params: Specific keyword arguments for the datasource.
    :rtype: boolean.
    :raises KeyError: If the type of data source is not implemented.
    :raises gramola.datasource.InvalidDataSourceConfig: The datasource_params are invalid.
    :raises gramola.store.DuplicateEntry: If the datasource name already exists.
    """
    # find the right class ipmlementation
    cls_datasource = DataSources.find([datasource_params['type']])

    # create a spceific configuration for this data source and instantiate
    config = cls_datasource.DATA_SOURCE_CONFIGURATION_CLS(**datasource_params)
    data_source = cls_datasource(config)

    # if test is not disabled specifically the datasource wont be saved
    # until it will pass the test step.
    if test:
        try:
            if not data_source.test():
                log.error("Testing the datasource .... Failed")
                return False
            log.info("Testing the datasource .... Ok")
        except Exception, e:
            log.error("Testing the datasource .... Error")
            raise e

    if dry_mode:
        log.info("Running in dry-mode, nothing more todo")
        return True

    user_store = store or DefaultStore()
    user_store.save_datasource(config)


def build_datasource_echo_type(datasource):
    """
    Build the datasource-echo command for one type of datasource, it turns out
    in a new command named as datasource-echo-<type>.
    """

    class DataSourceEchoCommand(GramolaCommand):
        NAME = 'datasource-echo-{}'.format(datasource.TYPE)
        DESCRIPTION = 'Echo a datasource {} configuration'.format(datasource.TYPE)
        USAGE = '%prog {}'.format(" ".join([s.upper() for s in datasource.DATA_SOURCE_CONFIGURATION_CLS.required_keys()]))

        @staticmethod
        def execute(**datasource_params):
            """ Echo a datasource configuration to be used by query command

            :param name: Name of the datasource.
            :param store: Alternatvie :class:`gramola.store.Store` to the default one.
            :rtype: boolean.
            :raises KeyError: If the type_ of data source is not implemented.
            :raises gramola.datasource.InvalidDataSourceConfig: The datasource_params are invalid.
            """
            temporaly_params = {
                # Type is a required param that is coupled with
                # with the command.
                'type': datasource.TYPE,

                # A echo command doesnt need the name keyword even it is required,
                # we share the same interface than the command to add datasources then
                # we have to give a automatic name to avoid raise an
                # InvalidDataSourceConfig error
                'name': 'stdout'
            }
            temporaly_params.update(datasource_params)
            return datasource.DATA_SOURCE_CONFIGURATION_CLS(
                    **temporaly_params).dumps()

        @staticmethod
        def options():
            return [(None, "--{}".format(key), key) for key in
                datasource.DATA_SOURCE_CONFIGURATION_CLS.optional_keys()]

    return DataSourceEchoCommand
   

class DataSourceListCommand(GramolaCommand):
    NAME = 'datasource-list'
    DESCRIPTION = 'List all saved datasources'

    @staticmethod
    def execute(store=None):
        """ List all datasouces.

        :param store: Alternatvie :class:`gramola.store.Store` to the default one.
        :return: list of derivated instancess of
                 :class:`gramola.datasources.base.DataSourceConfig`
        """
        user_store = store or DefaultStore()
        return user_store.datasources()


def build_datasource_query_type(datasource):
    """
    Build the query command for one type of datasource, it turns out
    in a new command named as query-<type>.
    """

    class QueryCommand(GramolaCommand):
        NAME = 'query-{}'.format(datasource.TYPE)
        DESCRIPTION = 'Query for a specific metric.'
        USAGE = '%prog {}'.format(" ".join([s.upper() for s in datasource.DATA_SOURCE_CONFIGURATION_CLS.required_keys()]))

        @staticmethod
        def execute(name, store=None, **query_params):
            """ Runs a query using a datasource and print it as a char graphic

            :param name: Name of the datasource used, the datasource will be get from
                         the user store. Altought special char `-` can be used as alternative
                         to read the datasource config from the stdin.
            :param store: Alternatvie :cls:`gramola.store.Store` to the default Gramola directory store.
            :raises InvalidDataSourceConfig: Data source config is invalid.
            :raises InvalidMetricQuery: Query params are invalid.
            :raises KeyError: If the given datasource name does not exist.
            :raises ValueError: If the given datasource from stdin is not well formatted.
            """
            if name == '-':
                buffer_ = sys.stdin.read()
                config = loads(buffer_)
            else:
                try:
                    config = filter(lambda d: d['name'] == name, user_store.datasources())[0]
                except IndexError:
                    raise KeyError(name)

            query = datasource.METRIC_QUERY_CLS(**query_params)
            datapoints = datasource.from_config(**config).datapoints(query)
            return sparkline.sparkify([value for value, ts in datapoints])

    return QueryCommand


def gramola():
    """ Entry point called from binary generated by setuptools. Beyond
    the main command Gramola immplements a sub set of commands that each one
    implements an specific opeartion. The anatomy of a Gramola command looks like:

        $ gramola <global options> <subcommand> <subcommand options> <args ..>
    """
    # Build as many datasource-echo commands as many types of datasources there are.
    typed_commands = [build_datasource_echo_type(datasource)\
        for datasource in DataSource.implementations()]
 
    # Build as many query commands as many types of datasources there are.
    query_commands = [build_datasource_query_type(datasource)\
        for datasource in DataSource.implementations()]

    # Use the gramola.contrib.subcommands implementation to wraper the
    # GramolaCommands as a subcommands availables from the main command.
    subcommands = []
    for gramola_subcommand in  GramolaCommand.commands():
        cmd = Subcommand(gramola_subcommand.NAME,
                         optparse.OptionParser(usage=gramola_subcommand.USAGE),
                         gramola_subcommand.DESCRIPTION)
        for opt in gramola_subcommand.options():
            cmd.parser.add_option(opt)

        subcommands.append(cmd)
    
    parser = SubcommandsOptionParser(subcommands=subcommands)
    parser.add_option('-s', '--store', dest='store',
                      help='alternative store directory, default ~/.gramola')
    parser.add_option('-q', dest='quite', help='Be quite', action='store_true')
    parser.add_option('-v', dest='verbose', help='Be verbose', action='store_true')

    options, subcommand, suboptions, subargs = parser.parse_args()
    
    log.setup(verbose=options.v, silent=options.q)
    try:
        cmd = GramolaCommand.find(subcommand)
    except KeyError:
        parser.print_hellp()
        sys.exit(1)
